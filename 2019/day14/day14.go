package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
)

type node struct {
	// amount of chemical in posession
	store int
	// amount of product generated by 1 reaction with edges
	amountGeneratedByReac int
	// chemicals needed to react with to generate this node
	edges []edge
}

type edge struct {
	// how much is needed in reaction
	amount int
	// chemical name
	dest string
}

var (
	inputFilePath = flag.String("input", "day14.txt", "input file path")
	partB         = flag.Bool("partB", false, "enable part b")
)

func main() {

	flag.Parse()
	file, err := os.Open(*inputFilePath)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	graph := parseInput(file)

	process(graph)

	fmt.Println(-1 * graph["ORE"].store)
}

func process(g map[string]node) {

	q := make([]string, 0)
	q = append(q, "FUEL")
	f := g["FUEL"]
	// continue until fuel reaches 0
	f.store = -1
	g["FUEL"] = f

	for len(q) > 0 {
		curr := q[0]
		q = q[1:]

		currNode := g[curr]
		g[curr] = currNode

		// Keep reacting until amount of
		// current chemical is not less than 0
		for currNode.store < 0 {
			if curr == "ORE" {
				break
			}

			// Do reaction
			for _, e := range currNode.edges {
				destNode := g[e.dest]
				destNode.store -= e.amount
				g[e.dest] = destNode
				q = append(q, e.dest)
			}
			currNode.store += currNode.amountGeneratedByReac
		} // end reaction
		g[curr] = currNode
	} // end all reactions for product

}

func parseInput(r io.Reader) map[string]node {
	scanner := bufio.NewScanner(r)

	graph := make(map[string]node)

	for scanner.Scan() {
		text := scanner.Text()
		eqnSplit := strings.Split(text, "=>")

		lhs := strings.Trim(eqnSplit[0], " ")
		lhsParts := strings.Split(lhs, ",")

		rhs := strings.Trim(eqnSplit[1], " ")
		rhsParts := strings.Split(rhs, " ")
		rhsChemical := rhsParts[1]
		rhsAmount := toInt(rhsParts[0])
		rhsNode := graph[rhsChemical]
		rhsNode.amountGeneratedByReac = rhsAmount

		for _, lhsPart := range lhsParts {
			lhsPart = strings.Trim(lhsPart, " ")
			lhsPartSplit := strings.Split(lhsPart, " ")
			amount := toInt(lhsPartSplit[0])
			chemical := lhsPartSplit[1]
			rhsNode.edges = append(rhsNode.edges, edge{amount, chemical})
		}
		graph[rhsChemical] = rhsNode
	}
	return graph
}

func toInt(s string) int {
	v, err := strconv.Atoi(s)
	if err != nil {
		log.Fatal(err)
	}
	return v
}
